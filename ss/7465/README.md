문제

n개의 아이템에 대해 1:1 쌍을 m개 주고 총 몇개의 그룹인지를 묻는 문제

입력

두 정수 N, M(1 ≤ N ≤ 100, 0 ≤ M ≤ N(N-1)/2) 이 공백 하나로 구분되어 주어진다.
같은 관계는 반복해서 주어지지 않는다.

결국 DFS로 풀었다. 
1. 백터 배열을 선언, 정점의 방문여부를 확인할 수 있는 bool 배열도 선언하였다.
2. 한 쌍을 입력 받는다
3. 하나의 아이템 뒤에 다른 아이템을 붙인다. 역방향도 마찬가지
4. 1..n까지 하나의 아이템을 깊이 탐색 시도한다 5번 반복
5. 방문하였으므로 체크 해주고, 체크한 아이템의 이웃에 대해 아직 방문하지 않은 아이템이라면 재귀적 방법으로 깊이 탐색 진입한다.
6. 깊이 탐색이 모두 끝나면 카운트를 올린다.

#교훈
*C++로 새로 전환하면서 백터와 queue 사용을 배움.
*BFS로 풀릴 것 같은데 런타임 에러 나온다...대체 왜? 이것 때문에 이 간단한 문제를 6시간이나..-_-;


#fail case //BFS 왜죠..
1. n by n+1 의 배열을 구성한다
2. 한 쌍을 입력 받는다
3. 쌍을 열어 아이템의 arr[a][0], arr[b][0]를 True로 셋팅한다
4. arr[a][b], arr[b][a]를 True로 셋팅한다
3. queue를 구성한다
4. 1..n까지 arr[n][0] == true면 queue에 넣는다. cnt++, arr[n][0] = false
7. queue가 empty될 때 까지
*queue에서 아이템을 꺼낸다 
*꺼낸 아이템의 arr[n][1..n]까지 탐색하면서 true아이템을 push한다
*push한 아이템의 arr[i][0]를 false로 셋팅한다

#TC
1
6 5
1 2
2 5
5 3 
3 4
4 6
#1 1

1
5 3
1 2
3 4
5 1
#1 2


2
6 5
1 2
2 5
5 1
3 4
4 6
6 8
1 2
2 5
5 1
3 4
4 6
5 4
2 4
2 3
#1 2
#2 1

4
6 5
1 2
2 5
5 1
3 4
4 6
6 8
1 2
2 5
5 1
3 4
4 6
5 4
2 4
2 3
6 5
1 2
2 5
5 3 
3 4
4 6
5 3
1 2
3 4
5 1

2
6 5
1 2
2 5
5 3 
3 4
4 6
5 3
1 2
3 4
5 1